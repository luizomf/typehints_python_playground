Voc√™ pode gerar o SEO do Youtube para mim seguindo o modelo ao final desse prompt? Os dados que est√£o ao final do texto s√£o apenas um exemplo do formato que quero que voc√™ siga. Os dados da aula para qual vamos gerar o conte√∫do est√£o nos c√≥digos abaixo.

--- 

File: exemplo38.py
from collections.abc import Sequence
from typing import TypeGuard, reveal_type

from utils import sep_print

################################################################################
#
# TypeGuard no Python: O Fiscal de Tipos Que Voc√™ N√ÉO Conhece üö® (Aula 16)
#
# `TypeGuard[T]` e `TypeIs[T]` s√£o usados para "Type Narrowing" (afunilamento de tipo)
# no Python. Ambas fazem algo similar ao que j√° vimos com `isinstance()`, por√©m
# diferem nos argumentos de entrada e no contexto.
# `TypeGuard` funciona de uma forma contra intuitiva, enquanto `TypeIs` √© bem
# mais tranquilo de ser utilizado.
#
################################################################################
#
# Obs.: As PEPs 742 e 647 falam sobre `TypeIs` e `TypeGuard`. Nessa aula vamos
# focar em `TypeGuard` e na pr√≥xima falamos sobre `TypeIs`.
#
################################################################################
#
# Uma forma bem simples de entender o que `TypeGuard[T]` e `TypeIs[T]` fazem √©
# sempre imaginar cada um deles como `isinstance()` s√≥ que dentro da sua pr√≥pria
# fun√ß√£o, com seus argumentos e retorno de tipo. Depois √© s√≥ entender as
# peculiaridades de cada um.
#
################################################################################
#
# Como `TypeGuard[T]` Funciona? (`T` sendo tipo target)
#
# - Usado para anotar o retorno de uma fun√ß√£o de afunilamento de tipo (Type Predicate).
# - Se o retorno da fun√ß√£o for `True`, o tipo √© afunilado para `T`.
# - Se o retorno da fun√ß√£o for `False`, explico mais abaixo em "IMPORTANTE".
# - D√° para enviar muitos args para a fun√ß√£o, mas o primeiro √© para o tipo de entrada.
# - O tipo do primeiro argumento pode n√£o ter rela√ß√£o com `T`.
# -` TypeGuard[T]` PODE ser gen√©rico (`T` pode ser din√¢mico).
# - `TypeGuard[T]` aceita `Callable[..., T]` e Callback Protocol (que vimos antes).
#
################################################################################
#
# IMPORTANTE: `TypeGuard[T]` faz type "cast" permanente no caminho `True`. Por
# isso, ao analisar o c√≥digo ap√≥s o bloco `if/else`, o type checker precisa
# considerar as duas possibilidades que poderiam ter acontecido: o tipo original
# (se o caminho `False` foi seguido) e o novo tipo `T` (se o caminho `True` foi
# seguido). Por isso, ele cria uma Union para representar essa incerteza.
#
################################################################################


def is_list_str(values: Sequence[object]) -> TypeGuard[list[str]]:
    return all(isinstance(v, str) for v in values)


################################################################################


if __name__ == "__main__":
    sep_print()

    items1 = [22, "a"]
    if is_list_str(items1):
        reveal_type(items1)  # list[str] -> Comportamento esperando
    else:
        reveal_type(items1)  # list[str | int] -> Comportamento esperado

    # Fora do bloco condicional, o type checker n√£o faz ideia se seu tipo √©
    # `list[str]` ou `list[str | int]`. Para Ele agora existem dois caminhos
    # poss√≠veis: `list[str]` ou `list[str | int]`. Isso √© porque o `TypeGuard`
    # faz `cast` permanente ap√≥s seu uso.

    # Aqui o tipo √© a altera√ß√£o permanente do TypeGuard ou o seu tipo
    reveal_type(items1)  # list[str] | list[str | int]

    sep_print()

################################################################################

File: exemplo39.py
import json
from pathlib import Path
from typing import Any, TypedDict, TypeGuard, cast

from utils import cyan_print, red_print, sep_print

################################################################################
#
# TypeGuard - Exemplo real de uso lendo JSON (Aula 16)
#
# Quando usar `TypeGuard`?
#
# - Quando o tipo de entrada n√£o est√° relacionado com o tipo de sa√≠da.
# - Quando n√£o sei o tipo dos dados que estou recebendo e preciso ser muito gen√©rico.
# - Quando estou recebendo dados que podem ser inv√°lidos (APIs, arquivos, etc).
# - Quando preciso fazer `cast` para trabalhar com seguran√ßa dentro da condicional.
#
# Aten√ß√£o: √© bom ter bastante certeza que sua fun√ß√£o de an√°lise fa√ßa a checagem
# de TODOS OS CAMINHOS POSS√çVEIS. Se enganarmos o Type Checker, estaremos nos enganando
# tamb√©m. O "cast" √© permanente para o Type Checker.
#
################################################################################


class UserDict(TypedDict):
    firstname: str
    lastname: str
    age: int


def is_valid_dict(item: object) -> TypeGuard[UserDict]:
    if not isinstance(item, dict):
        return False

    item = cast("dict[Any, Any]", item)  # isso √© para o Pyright para de amolar

    if not isinstance(item.get("firstname"), str):
        return False

    if not isinstance(item.get("lastname"), str):
        return False

    return isinstance(item.get("age"), int)


################################################################################


if __name__ == "__main__":
    sep_print()

    input_file = Path("exemplo39.json").resolve()
    with input_file.open("r", encoding="utf8") as file:
        user_data = json.load(file)  # Any

    for user in user_data:
        if is_valid_dict(user):
            cyan_print("‚úÖ VALID USER")
            cyan_print(f"{user['firstname']} {user['lastname']} {user['age']}")
        else:
            red_print("‚ùå INVALID DATA ‚ùå")
            red_print(user)

    sep_print()

################################################################################

---

A PARTIR DAQUI √â EXEMPLO DE COMO PRECISO DA RESPOSTA:

---

#-------------------------------------------------------------------------------
Este arquivo √© TXT puro
#-------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
T√≠tulo
#-------------------------------------------------------------------------------

Python NewType - Tipos Iguais Mas Diferentes? (Type Hints - Aula 15)

#-------------------------------------------------------------------------------
Descri√ß√£o
#-------------------------------------------------------------------------------

Voc√™ j√° precisou validar uma estrutura de dados complexa em Python, como um dicion√°rio vindo de um JSON, e sentiu que o isinstance() simplesmente n√£o era o suficiente? Na Aula 16 do nosso curso, vamos conhecer a ferramenta de "for√ßa bruta" da tipagem est√°tica: o TypeGuard.

Prepare-se para conhecer o "guarda-costas louco", "o fiscal de tipagem" do sistema de tipos do Python. O TypeGuard √© uma ferramenta poderosa que nos permite criar nossas pr√≥prias fun√ß√µes de valida√ß√£o que "ensinam" o type checker. No entanto, ele tem um comportamento contraintuitivo e "perigoso": ele realiza um "cast" permanente no tipo da sua vari√°vel.

Nesta aula, vamos desvendar esse mist√©rio. Primeiro, vamos entender a teoria e por que o TypeGuard se comporta de forma t√£o estranha, criando Unions inesperadas. Depois, vamos para a pr√°tica e construir um validador de TypedDict do mundo real, criando uma ponte segura entre dados n√£o confi√°veis de um arquivo JSON e o nosso c√≥digo tipado.

Nesta aula da nossa playlist completa sobre Type Hints no Python, voc√™ vai aprender:

- O que √© TypeGuard e como ele funciona para afunilamento de tipo (Type Narrowing).
- O comportamento "perigoso" de "casting permanente" e por que ele altera o tipo da sua vari√°vel fora do if.
- Um exemplo pr√°tico e real: como validar a estrutura de um dicion√°rio (vindo de um JSON) contra um TypedDict.
- Quando e por que usar TypeGuard para lidar com dados de fontes externas e n√£o confi√°veis.

Esta √© uma aula essencial para quem quer dominar as ferramentas avan√ßadas de tipagem e escrever um c√≥digo defensivo e robusto.

E lembre-se: Type Hint √© igual a Type Annotation (tipagem no Python).

Este v√≠deo √© parte de uma playlist, essa √© a D√âCIMA SEXTA aula. Segue o link da playlist para acompanhar:
https://www.youtube.com/playlist?list=PLbIBj8vQhvm04EuddtleOAoEmfU9vwQlN

Link do reposit√≥rio:
https://github.com/luizomf/typehints_python

Conhe√ßa meus cursos em:
https://www.otaviomiranda.com.br/

Cap√≠tulos
00:00:00 - Introdu√ß√£o: O Guarda-Costas Louco do Python
00:00:00 - A Teoria: Como o TypeGuard funciona?
00:00:00 - O Comportamento Estranho: O "Cast" Permanente e a Union Resultante
00:00:00 - Exemplo Pr√°tico: Validando um JSON com TypedDict
00:00:00 - Criando o TypedDict e a Fun√ß√£o de Valida√ß√£o
00:00:00 - Usando o TypeGuard para Afunilar o Tipo de Any
00:00:00 - Conclus√£o: Quando e Por Que Usar o TypeGuard?


#Python #TypeHints #TypeGuard #CleanCode #PythonBrasil

#-------------------------------------------------------------------------------
At√© 5 hashtags
#-------------------------------------------------------------------------------

#Python #TypeHints #TypeGuard #CleanCode #PythonBrasil

#-------------------------------------------------------------------------------
Tags invis√≠veis do Youtube separadas por v√≠rgula (m√°x. 500 caracteres)
#-------------------------------------------------------------------------------

python typeguard,typing.TypeGuard,type narrowing python,type checker python,refinamento de tipo python,curso de type hints,python avan√ßado,python typing tutorial,evitar bugs com typeguard,python para seniores,tipagem est√°tica avan√ßada,luiz otavio miranda,typeguard vs typeis,pep 647,pep 724,python moderno,type hints python,arquitetura limpa python

#-------------------------------------------------------------------------------
Fim
#-------------------------------------------------------------------------------

Voc√™ pode gerar o SEO do Youtube para mim seguindo o modelo ao final desse prompt? Os dados que est√£o ao final do texto s√£o apenas um exemplo do formato que quero que voc√™ siga. Os dados da aula para qual vamos gerar o conte√∫do est√£o nos c√≥digos abaixo.

ABAIXO OS C√ìDIGOS E CONCEITOS QUE CRIAMOS NA AULA

---

File: exemplo46.py
from dataclasses import dataclass
from typing import Annotated, get_args, get_origin, get_type_hints

from utils import cyan_print, sep_print

p = cyan_print
s = sep_print

################################################################################
#
# Python Annotated: O Que √© T√£o Especial Nele? (Type Hints - Aula 19)
#
# Annotated √© um tipo parametrizado especial do Python usado para adicionar
# metadados em outros tipos. Ele recebe um tipo para o primeiro argumento e pelo
# menos um valor para o segundo.
#
# Inteiro = Annotated[int, "Um n√∫mero inteiro"] # int para o type checker
#
# Voc√™ pode passar o que preferir do segundo argumento em diante, incluindo
# fun√ß√µes, classes, valores escalares, etc.
#
# O Type Checker considera o primeiro argumento como tipo, o restante
# pode ser usado para v√°rias situa√ß√µes, como: documenta√ß√£o, valida√ß√£o,
# informa√ß√µes em geral, modifica√ß√£o, enfim... Depende do que a sua imagina√ß√£o
# conseguir produzir.
#
# A parte mais interessante de Annotated √© que voc√™ consegue usar os metadados
# em runtime, por isso voc√™ v√™ v√°rias libs e frameworks abusando do seu usado
# (voc√™ tamb√©m deveria usar). Pydantic, FastAPI, Langchain e Langgraph s√£o
# algumas das ferramentas que usam bastante Annotated para tipagem e metadados
# em runtime.
#
# Com o que usar Annotated? classes, fun√ß√µes, m√≥dulos e objetos.
#
# Fun√ß√µes que acompanham Annotated:
#
# - get_type_hints - Retorna os dados de tipagem para fun√ß√£o, m√©todo, objeto ou m√≥dulo.
# - get_args - Retorna os argumentos internos do tipo parametrizado ou composto.
# - get_origin - Retorna o tipo "externo". Ex. Se o tipo √© X[A, B, ...], retorna X.
# - e outras...
#
################################################################################


def simple_annotation(
    annotated: Annotated[object, "I have annotation"],
) -> Annotated[object, "I have annotation"]:
    return annotated


s()

type_hints = get_type_hints(simple_annotation, include_extras=True)
type_args = get_args(type_hints["annotated"])
type_return = get_args(type_hints["return"])
type_origin = get_origin(type_hints["annotated"])

p(f"{type_hints=!r}")
p(f"{type_args=!r}")
p(f"{type_return=!r}")
p(f"{type_origin=!r}")

s()


################################################################################

# Exemplo de classe com atributos anotados


@dataclass
class Person:
    """A person object"""

    name: Annotated[str, "O nome completo da pessoa"]
    age: Annotated[int | None, "A idade"] = None


################################################################################

#
# Exemplo para verificar os metadados em runtime (prints para simplicidade)
#
# Observa√ß√£o: n√£o fiz todos os testes poss√≠veis nessa fun√ß√£o. Isso vai depender
# do que voc√™ for fazer.
#


def print_annotated[T: object](obj: T) -> T:
    # Pegamos a classe do objeto
    obj_class = obj.__class__
    # Tentamos obter o __name__ se tiver um
    obj_name = getattr(obj, "__name__", "")

    if not obj_name:
        # Se n√£o tiver nome, vamos pegar o nome da classe.
        # Geralmente isso vai ser inst√¢ncia da classe (tem que checar)
        obj_name = obj_class.__name__

    # Pega os dados das annotations
    # get_type_hints retorna um dicion√°rio com chave e tipo anotado
    # o include_extras=True √© para vir os metadados (padr√£o False)
    hints = get_type_hints(obj, include_extras=True)

    if not hints:
        # Se n√£o tem hints, nada a fazer
        return obj

    # Agora √© s√≥ exibir tudo
    p("üßê Verificando a tipagem de:", obj_name)
    p(f"üé≤ Objeto Real: {obj!r}")
    for key, value in hints.items():
        # IMPORTANTE: podemos receber uma inst√¢ncia de classe, uma classe,
        # um m√©todo ou fun√ß√£o. Em termos de classe, fun√ß√µes, m√©todos e m√≥dulos,
        # n√£o temos nenhum valor dispon√≠vel.
        val = getattr(obj, key, "NO VALUE")

        # get_args vai trazer o tipo e o resto que estiver dentro de Annotated
        type_, *metadata = get_args(value)
        p(
            f"üîë Key={key!r} üìã Type={type_!r} üìù Meta={metadata!r} Value={val!r}",
        )
    p()
    s()

    return obj


################################################################################


if __name__ == "__main__":
    print_annotated(simple_annotation)

    person = Person("Luiz", 30)
    print_annotated(person)

    print_annotated(Person)


################################################################################

File: exemplo47.py
import inspect
from abc import ABC, abstractmethod
from collections.abc import Callable
from functools import wraps
from typing import Annotated, get_args, get_type_hints

from utils import cyan_print, sep_print

p = cyan_print
s = sep_print

################################################################################
#
# Python Annotated: Exemplo simples!
#
# Dica: se vai fazer uma coisa complexa que outra lib j√° faz, usa ela. Isso
# pode se tornar muito complexo muito r√°pido.
#
################################################################################


def validate_annotated[**P, R](func: Callable[P, R]) -> Callable[P, R]:
    """Decorator que valida o que for anotado com Annotated e Validator"""

    # Obtemos as annotations da fun√ß√£o
    hints = get_type_hints(func, include_extras=True)
    # Isso vai nos ajudar a inspecionar a fun√ß√£o
    signature = inspect.signature(func)

    @wraps(func)  # Boa pr√°tica üëç
    def wrapper(*args: P.args, **kwargs: P.kwargs) -> R:
        # Agora podemos pegar os argumentos e seus valores
        bound_arguments = signature.bind(*args, **kwargs)
        bound_arguments.apply_defaults()

        # Se n√£o encontrarmos nenhuma annotation, retornamos
        if not hints:
            return func(*args, **kwargs)

        # Loop nos nomes dos argumentos da fun√ß√£o
        for arg_name in bound_arguments.arguments:
            # Se o nome que eu recebi aqui n√£o est√° anotado, pr√≥ximo...
            if arg_name not in hints:
                continue

            # Pego o valor do argumento
            value = bound_arguments.arguments[arg_name]
            # Pego os dados do argumento
            metadata = get_args(hints[arg_name])

            # S√≥ vou conferir algo que tenha mais de um valor
            # o segundo valor pode ser um ou mais validadores
            if len(metadata) <= 1:
                continue

            # Pegamos o tipo e os poss√≠veis validadores
            type_, *validators = metadata

            # Vamos passar em todos checando se s√£o mesmo validadores
            for validator in validators:
                if not isinstance(validator, Validator):
                    continue

                # Se s√£o, quero garantir que o tipo tamb√©m est√° correto
                if not isinstance(value, type_):
                    msg = (
                        f"Argument {arg_name!r} should be of type {type_!r} "
                        f"in {func.__name__!r}. Got {type(value)!r}."
                    )
                    raise TypeError(msg)

                # E agora √© s√≥ validar
                # Obs.: J√° chequei o tipo, pyright n√£o reconheceu
                validator.validate(value)  # pyright: ignore[reportUnknownMemberType]

        # Executamos a fun√ß√£o original com os argumentos bonitinhos
        return func(*args, **kwargs)

    # Te dou uma nova fun√ß√£o
    return wrapper


################################################################################


# Exemplo de uma hierarquia de validadores


class ValidationError(Exception):
    """Uma exce√ß√£o com nome mais sem√¢ntico"""


class Validator[T](ABC):
    """Contrato que os validadores prometem cumprir"""

    @abstractmethod
    def validate(self, value: T) -> T: ...


class IntRange(Validator[int]):
    """Valida um range de n√∫meros"""

    def __init__(self, min_: int, max_: int) -> None:
        self.min = min_
        self.max = max_

    def validate(self, value: int) -> int:
        if value < self.min or value > self.max:
            msg = f"{value} is out of range ({self.min}, {self.max})"
            raise ValidationError(msg)

        return value


class StrMaxLength(Validator[str]):
    """Valida uma string com tamanho m√°ximo"""

    def __init__(self, max_: int) -> None:
        self.max = max_

    @validate_annotated
    def validate(self, value: str) -> str:
        if len(value) > self.max:
            msg = f"{value!r} has more than {self.max} characters"
            raise ValidationError(msg)

        return value


################################################################################


@validate_annotated
def set_height(height: Annotated[int, IntRange(1, 100)]) -> int:
    """Set the widget height"""
    p(f"Height is set to {height}")
    return height


@validate_annotated
def set_app_name(
    name: Annotated[str, StrMaxLength(10)],
) -> str:
    """Change app name"""
    p(f"App name is now {name!r}")
    return name


################################################################################


if __name__ == "__main__":
    new_app_name = set_app_name(name="My App")
    new_height = set_height(height=1)


################################################################################

---

A PARTIR DAQUI √â EXEMPLO DE COMO PRECISO DA RESPOSTA:

---

#-------------------------------------------------------------------------------
Este arquivo √© TXT puro
#-------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
T√≠tulo
#-------------------------------------------------------------------------------

ParamSpec e Concatenate no Python: Voc√™ PRECISA DISSO Para Closures! (Aula 18)

#-------------------------------------------------------------------------------
Descri√ß√£o
#-------------------------------------------------------------------------------

Voc√™ j√° criou um decorador em Python e, de repente, percebeu que ele "engoliu" toda a tipagem da sua fun√ß√£o original? O autocomplete para de funcionar, o type checker fica cego, e a seguran√ßa que voc√™ tinha se foi. Na Aula 18, vamos resolver esse problema de uma vez por todas com a "arma secreta" da tipagem: ParamSpec.

Neste v√≠deo, vamos mergulhar fundo no Parameter Specification (PEP 612) e na nova sintaxe da PEP 695. Voc√™ vai aprender a criar decoradores que preservam 100% da assinatura da fun√ß√£o decorada, par√¢metros, nomes, tipos, argumentos posicionais e nomeados, como se fossem um "envelope transparente".

Vamos do b√°sico, entendendo como o ParamSpec captura uma assinatura, at√© o avan√ßado, usando Concatenate para adicionar novos par√¢metros e construindo um Decorator Factory do zero: um validador de tipos em runtime que funciona como um "mini Pydantic pobre" haha.

Nesta aula da nossa playlist completa sobre Type Hints no Python, voc√™ vai aprender:

- O problema fundamental dos decoradores que "apagam" os tipos.
- O que √© ParamSpec e como ele "fotografa" a assinatura de uma fun√ß√£o.
- A receita completa para criar um decorador que preserva os tipos usando ParamSpec e TypeVar.
- Como usar Concatenate para criar decoradores que injetam argumentos em uma fun√ß√£o.
- O padr√£o "Decorator Factory": como criar decoradores que aceitam argumentos.
- Um exemplo pr√°tico e real: um decorador @validate_types que checa os tipos dos argumentos em runtime.

Se voc√™ quer parar de lutar com Callable[..., Any] e aprender a criar decoradores robustos e com tipagem perfeita, esta aula √© o seu guia definitivo.

E lembre-se: Type Hint √© igual a Type Annotation (tipagem no Python).

Este v√≠deo √© parte de uma playlist, essa √© a D√âCIMA S√âTIMA aula. Segue o link da playlist para acompanhar:
https://www.youtube.com/playlist?list=PLbIBj8vQhvm04EuddtleOAoEmfU9vwQlN

Link do reposit√≥rio:
https://github.com/luizomf/typehints_python

Meus Cursos: https://www.otaviomiranda.com.br/
Newsletter: https://luizomf.substack.com/

Cap√≠tulos
00:00:00 - Introdu√ß√£o ao ParamSpec no Python
00:02:20 - Qual o problema Parameter Specification Resolve?
00:06:36 - ParamSpec, a solu√ß√£o din√¢mica para par√¢metros de fun√ß√µes
00:08:15 - ParamSpec, closures, decorators, args e kwargs
00:18:40 - ParamSpec com Concatenate para par√¢metros adicionais
00:23:10 - Simulando o Pydantic com Decorator Factory e ParamSpec

#Python #TypeHints #Decorators #DesignPatterns #PythonBrasil

#-------------------------------------------------------------------------------
At√© 5 hashtags
#-------------------------------------------------------------------------------

#NeoVim #Vim #Programa√ß√£o #Produtividade #Desenvolvedor

#-------------------------------------------------------------------------------
Tags invis√≠veis do Youtube separadas por v√≠rgula (m√°x. 500 caracteres)
#-------------------------------------------------------------------------------

neovim para iniciantes,comandos neovim,atalhos neovim,vim tutorial,vim productivity,vim navigation,hjkl,text objects neovim,vim text objects,vim advanced,neovim tips and tricks,neovim pt-br,neovim tutorial portugues,vim for developers,vim for vs code users,vim macros,vim visual mode,vim visual block,vim for beginners

#-------------------------------------------------------------------------------
Fim
#-------------------------------------------------------------------------------

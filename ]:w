# ruff: noqa: B903
#
# Classes - Vamos relembrar (Vai ser muito importante)
#
# RUNTIME (Código em tempo de execução):
# Classes são fábricas de objetos. Elas funcionam como moldes para gerar novas
# estruturas de dados na linguagem.
# Por exemplo: ao criar a classe `Animal`, o que você fez foi criar uma nova
# fábrica de objetos do tipo `Animal`.
# Tudo o que foi definido em `Animal` (o molde), será passado para os objetos
# fabricados pela classe `Animal`.
# Esses objetos agora são chamados e "instâncias" da classe `Animal`.
# Um `Dog` criado por `Animal` é uma instância de `Animal`. Assim como um `Cat`.
# Dentro da classe, podemos nos referir à instância que está sendo criada
# usando a palavra `self`.
# Classe == Molde (a fábrica) | Instância == O que foi fabricado pela classe


from utils import cyan_print, sep_print


class Animal:
    def __init__(self, name: str) -> None:
        # self aqui é a instância que está sendo criada
        # Eu quero que todo `animal` tenha um `name` na inicialização
        self.name = name


# Criamos o molde, que tal criar animais?
dog = Animal("Dog")  # dog É UM Animal
cat = Animal("Cat")  # cat É UM Animal

# Todos os animais agora tem um `name`
sep_print()
cyan_print(f"{dog.name = !r}")  # Dog
cyan_print(f"{cat.name = !r}")  # Cat

#
# Para Type Checkers (Código não executado):
#
# Classes criam tipos. Assim como criamos `Animal` porque não encontramos um
# `Animal` pronto no Python, para o Type Checker, ao criar um `Animal`, você
# acabou de criar um novo tipo na linguagem chamado `Animal`. Todas as intâncias
# de animal são DO TIPO `Animal`. Se eu criar uma função que precisa receber um
# `Animal` (do exemplo anterior), `dog` ou `cat` vão servir.


def get_animal_name(animal: Animal) -> None:
    cyan_print(f"'get_animal_name' | Classe: {type(animal).__name__}")
    cyan_print(f"'get_animal_name' | {animal.name = !r}")
    sep_print()


sep_print()
get_animal_name(dog)  # Dog
get_animal_name(cat)  # Cat

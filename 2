from collections.abc import Callable
from typing import Final, Literal, Protocol, overload

CONSTANTE = "Seu valor será deve ser esse"
constante: Final = "valor"  # Literal["valor"]
constante2: Literal["valor"] = "valor"  # constante implícita

# You always should select de widest possible type
# for example: Sequence[str] is wider than List[str]


@overload
def do_sum(x: int, y: int) -> int: ...
@overload
def do_sum(x: float, y: float) -> float: ...
def do_sum(x: float, y: float) -> float:
    return x * y


abc = do_sum(1, 2)


class FuncType[**P, R](Protocol):
    def __call__(self, *args: P.args, **kwargs: P.kwargs) -> R: ...


def decor[**P, F](func: FuncType[P, F], *, should_print: bool = True) -> Callable[P, F]:
    def inner(*args: P.args, **kwargs: P.kwargs) -> F:
        if should_print:
            print("decorated")
        return func(*args, **kwargs)

    return inner


def add(x: float, y: float) -> float:
    return x + y


decorated_add = decor(add, should_print=False)

result1 = add(1, 2)
result2 = decorated_add(1, 2)


print(f"{result1= }")
print(f"{result2= }")
